/*
!!! See docs/SECURITY_RULES.md !!!
*/

path / {
  // Do not allow to read to /
  // Do not write to false to /
}

// -------------------------------------------------------------------- EXAMPLE

// For testing purposes (REMOVE IN PRODUCTION!)
path /example is Example[] {
  read() { isSignedIn() }

  write() { isSignedIn() }
}

/* INFO: Equivalent to definition above:
path /feature is Map<PushID,Feature> {
  <<Define all ruels in feature/schema.bolt>>
}
*/

// ----------------------------------------------------------------------- USER

function currentUserIsContactOf(userId) { prior(root.user[userId].contacts[auth.uid]) != null }
function otherUserIsMyContact(userId) { prior(root.user[auth.uid].contacts[userId]) != null }

path /user { // !
  write() { isHeliosSupport() }
  read() { isHeliosSupport() }
}

path /user/{uid} { // !
  read() { isUser(uid) }
}

path /user/{uid}/readonly is UserReadonly {
  read() { isUser(uid) }
  write() { false }

  /referralBonus {
    write() { this === prior(this) - 1 }
  }

  /subscription {
    write() { false } // Only cloud function can update subscription status
  }
}

path /user/{uid}/public is UserPublic {

  // TODO: Who can see public? anybody or just contacts?
  read() { isSignedIn() }
  // read() { currentUserIsContactOf(uid) }

  write() { isUser(uid) }
}

path /user/{uid}/settings is UserSettings {

  write() { isUser(uid) }

  /* special fields, see above */
  path /clientWipeoutRequest {
    // At all cost we want to avoid to trigger clientWipeoutRequest
    // while creating the user ;-)
  }
  path /clientActivationRequest {
    // clientActivationRequest is not created during user creation anymore
    // to avoid triggering of the create-user cloud function twice.
  }
}

path /user/{uid}/status is UserStatus {
  // Anyone can read a User's status information (who is signed in)
  read() { isSignedIn() }

  // Only authenticated users can write their own information
  write() { isUser(uid) }
}

// .............................................................................

path /user/{uid}/contacts {

  // The idea here is that contact are a list of people that I trust.
  // By adding a user to my contact list I trust this user, which means
  // I'm willing to RECEIVE messages and tasks
  // In order to SEND messages and tasks the other user has to add me
  // to his contact list

  // In order to create a mutual connection, a user can send an "Invitation",
  // which will (1) add the other user to my contact list (2) "ask" the other
  // user to add me

  path /{contactId} is UserContact {

    // Allow my contact to read my contact info about him
    read() {
      contactId === auth.uid
      // otherUserIsMyContact(contactId)
    }

    /numNewMessages {
      // TODO: GEHT NICHT. vllt weil vorher nicht vorhanden??
      write() { currentUserIsContactOf(uid) && ( this > prior(this) || prior(this) == null ) }
    }

    // Only I can create / update / delete contacts
    create() { isUser(uid) }
    update() { isUser(uid) }
    delete() { isUser(uid)  }
  }
}

type Message extends UserMsgInbox {}
path /user/{uid}/msginbox {

  // Allow other users to read their own sent messages
  read() {
    isSignedIn() &&
    query.orderByChild == 'senderUserId' &&
    query.equalTo == auth.uid &&
    query.limitToLast <= 101
  }

  path /{msgId} is Message {

    // Allow other users to write, but only if senderUserId == uid
    // and only if otgher user is in my contact list
    // We're checking the contact list to avoid spamming
    create() {
      isSignedIn() &&
      currentUserIsContactOf(uid) &&
      this.senderUserId === auth.uid
    }

    // Allow receiver to mark as unread/read, also allow changing the message
    update() {
      ( isUser(uid) && ( this.unread === false || this.unread === true ) )
      || prior(this.senderUserId) === auth.uid
    }

    // Allow sender and receiver to delete a message
    // delete() { isUser(uid) || prior(this.senderUserId) === auth.uid }

    // Allow only sender to delete their own messages
    delete() { prior(this.senderUserId) === auth.uid }

  }

  // Index
  index() { [ "senderUserId", "unread" ] }
}

// ----------------------------------------------------------------------- GOAL
function isGoalMember(goalId) { prior(root.goal[goalId].meta.members[auth.uid]) != null }
function isGoalAdmin(goalId)  { prior(root.goal[goalId].meta.members[auth.uid].isAdmin) }

function otherUserPrivacySettings(goalId,otherUserId) {
  root.goal[ goalId ].meta.members[ otherUserId ].privacy_settings[ auth.uid ]
}

function otherUserPrivacySettingsTeam(goalId,otherUserId) {
  root.goal[ goalId ].meta.members[ otherUserId ].privacy_settings[ 'TEAM' ]
  /* root.child('goal').child($goalId).child('meta').child('members').child($uid).child('privacy_settings').child('TEAM').child('allow_to_see_commitment').val() == true */
}

function isEditingContentField(this) {
  this.objective || this.name || this.description || this.rules || this.deadlineList || this.picture
}

path /goal/{goalId} {

  update() { isGoalAdmin(goalId) } // TODO: eigentlich auch nur bestimte felder!

  // Anybody can create a goal
  // TODO: limit number of goals per user?
  create() { true }
}

path /goal/{goalId}/user_list/{uid}/task_meta {
  // Allow to read/update/create/delete task meta if:
  // I'm member of this goal
  // AND it's my data
  // OR  the other user gave permission to me (allow_to_see_tasks/allow_to_edit_tasks)
  // OR  it's a team task (backlog)
  // OR  I'm a admin

  // TODO: task meta should only contain meta data (read/write needs to be updated then)

  // TODO: Does not include users who left
  read() {
    isGoalAdmin(goalId) ||
    isGoalMember(goalId) && (
      isUser(uid) ||
      uid === 'TEAM' ||
      otherUserPrivacySettings(goalId, uid).allow_to_see_tasks_details ||
      otherUserPrivacySettingsTeam(goalId, uid).allow_to_see_tasks_details
    )
  }
  path /{taskId} is TaskMeta {
    read() {
      isGoalAdmin(goalId) ||
      isGoalMember(goalId) && (
        uid === 'TEAM' ||
        isUser(uid) ||
        otherUserPrivacySettings(goalId, uid).allow_to_see_tasks ||
        otherUserPrivacySettingsTeam(goalId, uid).allow_to_see_tasks
      )
    }

    // TODO: !!! THIS WILL GRANT ACCESS TO **ALL** ITEMS IN /task_meta !!!
    // TODO: Does not include users who left
    write() {
      isGoalAdmin(goalId) ||
      isGoalMember(goalId) && (
        uid === 'TEAM' ||
        isUser(uid) ||
        otherUserPrivacySettings(goalId, uid).allow_to_edit_tasks ||
        otherUserPrivacySettingsTeam(goalId, uid).allow_to_edit_tasks
      )
    }
  }

  path /{taskId}/subscriptions/{subscriptionId} is TaskSubscription {
    write() {
      isGoalAdmin(goalId)
    }
    read() {
      isGoalMember(goalId)
    }
  }

  path /{taskId}/assignments/{assignmentId} is TaskAssignment {
    write() {
      isGoalAdmin(goalId)
    }
    read() {
      isGoalMember(goalId)
    }
  }
}

path /goal/{goalId}/user_list/{uid}/task_names/{id} {
  // Allow to read/update/create/delete task names if:
  // I'm member of this goal
  // AND it's my data
  // OR  the other user gave permission to me (allow_to_see_tasks/allow_to_edit_tasks)
  // OR  it's a team task (backlog)
  // OR  I'm a admin

  // TODO: Does not include users who left
  read() {
    isGoalAdmin(goalId) ||
    isGoalMember(goalId) && (
      isUser(uid) ||
      uid === 'TEAM' ||
      otherUserPrivacySettings(goalId, uid).allow_to_see_tasks ||
      otherUserPrivacySettingsTeam(goalId, uid).allow_to_see_tasks
    )
  }

  // TODO: !!! THIS WILL GRANT ACCESS TO **ALL** ITEMS IN /task_meta !!!
  // TODO: Does not include users who left
  write() {
    isGoalAdmin(goalId) ||
    isGoalMember(goalId) && (
      isUser(uid) ||
      uid === 'TEAM' ||
      otherUserPrivacySettings(goalId, uid).allow_to_edit_tasks ||
      otherUserPrivacySettingsTeam(goalId, uid).allow_to_edit_tasks
    )
  }
}

path /goal/{goalId}/user_list/{uid}/task_details {
//path /goal/{goalId}/user_list/{uid}/task_details/{taskId} is TaskDetails[] {

  // Allow to read/update/create/delete task details (e.g. checklists) if:
  // I'm member of this goal
  // AND it's my data
  // OR  the other user gave permission to me (allow_to_see_tasks_details/allow_to_edit_tasks_details)
  // OR  it's a team task (backlog)
  // OR  I'm a admin
  read() {
    isGoalAdmin(goalId) ||
    isGoalMember(goalId) && (
      isUser(uid) ||
      uid === 'TEAM' ||
      otherUserPrivacySettings(goalId, uid).allow_to_see_tasks_details ||
      otherUserPrivacySettingsTeam(goalId, uid).allow_to_see_tasks_details
    )
  }
  // TODO: Does not include users who left
  path /{taskId} is TaskDetails {
    read() {
      isGoalAdmin(goalId) ||
      isGoalMember(goalId) && (
        isUser(uid) ||
        uid === 'TEAM' ||
        otherUserPrivacySettings(goalId, uid).allow_to_see_tasks_details ||
        otherUserPrivacySettingsTeam(goalId, uid).allow_to_see_tasks_details
      )
    }

    // TODO: Does not include users who left
    write() {
      isGoalAdmin(goalId) ||
      isGoalMember(goalId) && (
        isUser(uid) ||
        uid === 'TEAM' ||
        otherUserPrivacySettings(goalId, uid).allow_to_edit_tasks_details ||
        otherUserPrivacySettingsTeam(goalId, uid).allow_to_edit_tasks_details
      )
    }
  }

  // Allow everybody to create new checklist items in bugtracker
  path /{taskId}/checklist/{checklistItemId} is TaskChecklistItem {
    create() {
      isSignedIn() && isBugtracker(goalId,taskId)
    }
    read() {
      isSignedIn() && isBugtracker(goalId,taskId)
    }
  }

  path /{taskId}/comment/{commentId} is TaskComment {
    // create, read, write, delete rules are the same as TaskDetails
  }
}
