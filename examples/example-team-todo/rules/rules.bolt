/*
!!! See docs/SECURITY_RULES.md !!!
*/

/* INFO: Equivalent to definition above:
path /feature is Map<PushID,Feature> {
  <<Define all rules in feature/schema.bolt>>
}
*/

path / {
  // Do not allow to read to /
  // Do not write to false to /
}

// ----------------------------------------------------------------------- USER

function currentUserIsContactOf(userId) { prior(root.user[userId].contacts[auth.uid]) != null }
function otherUserIsMyContact(userId) { prior(root.user[auth.uid].contacts[userId]) != null }

path /user { // !
  write() { isHeliosSupport() }
  read() { isHeliosSupport() }
}

path /user/{uid} { // !
  read() { isUser(uid) }
}

path /user/{uid}/readonly is UserReadonly {
  read() { isUser(uid) }
  write() { false }

  /referralBonus {
    write() { this === prior(this) - 1 }
  }

  /subscription {
    write() { false } // Only cloud function can update subscription status
  }
}

path /user/{uid}/public is UserPublic {

  // TODO: Who can see public? anybody or just contacts?
  read() { isSignedIn() }
  // read() { currentUserIsContactOf(uid) }

  write() { isUser(uid) }
}

path /user/{uid}/settings is UserSettings {

  write() { isUser(uid) }

  /* special fields, see above */
  path /clientWipeoutRequest {
    // At all cost we want to avoid to trigger clientWipeoutRequest
    // while creating the user ;-)
  }
  path /clientActivationRequest {
    // clientActivationRequest is not created during user creation anymore
    // to avoid triggering of the create-user cloud function twice.
  }
}

path /user/{uid}/status is UserStatus {
  // Anyone can read a User's status information (who is signed in)
  read() { isSignedIn() }

  // Only authenticated users can write their own information
  write() { isUser(uid) }
}

// .............................................................................

path /user/{uid}/contacts {

  // The idea here is that contact are a list of people that I trust.
  // By adding a user to my contact list I trust this user, which means
  // I'm willing to RECEIVE messages. In order to SEND messages and tasks
  // the other user has to add me to his contact list

  path /{contactId} is UserContact {

    // Allow my contact to read my contact info about him
    read() {
      contactId === auth.uid
      // otherUserIsMyContact(contactId)
    }

    // Only I can create / update / delete contacts
    create() { isUser(uid) }
    update() { isUser(uid) }
    delete() { isUser(uid) }

    /numNewMessages {
      write() { currentUserIsContactOf(uid) && ( this > prior(this) || prior(this) == null ) }
    }
  }
}

type Message extends UserMsgInbox {}
path /user/{uid}/msginbox {

  // Allow other users to read their own sent messages
  read() {
    isSignedIn() &&
    query.orderByChild == 'senderUserId' &&
    query.equalTo == auth.uid &&
    query.limitToLast <= 101
  }

  path /{msgId} is Message {

    // Allow other users to write, but only if senderUserId == uid
    // and only if otgher user is in my contact list
    // We're checking the contact list to avoid spamming
    create() {
      isSignedIn() &&
      currentUserIsContactOf(uid) &&
      this.senderUserId === auth.uid
    }

    // Allow receiver to mark as unread/read, also allow changing the message
    update() {
      ( isUser(uid) && ( this.unread === false || this.unread === true ) )
      || prior(this.senderUserId) === auth.uid
    }

    // Allow sender and receiver to delete a message
    // delete() { isUser(uid) || prior(this.senderUserId) === auth.uid }

    // Allow only sender to delete their own messages
    delete() { prior(this.senderUserId) === auth.uid }
  }

  // Index
  index() { [ "senderUserId", "unread" ] }
}

// ----------------------------------------------------------------------- TASKS
function isTasklistMember(tasklistId) { prior(root.tasklist[tasklistId].members[auth.uid]) != null }
function isTasklistOwner(tasklistId)  { prior(root.tasklist[tasklistId].members[auth.uid].isOwner) }

path /tasklist/{tasklistId} {

  update() { isTasklistOwner(tasklistId) } // TODO: eigentlich auch nur bestimte felder!

  // Anybody can create a tasklist
  // TODO: limit number of tasklists per user?
  create() { true }
}

path /tasklist/{tasklistId}/members {
  // ...
}

path /tasklist/{tasklistId}/meta {
  // ...
}

path /tasklist/{tasklistId}/tasks {

  read() {
    isTasklistOwner(tasklistId) || isTasklistMember(tasklistId)
  }

  path /{taskId} is TaskMeta {
    read() {
      isTasklistOwner(tasklistId) || isTasklistMember(tasklistId)
    }

    write() {
      isTasklistOwner(tasklistId) || isTasklistMember(tasklistId)
    }
  }

  // Allow everybody to create new checklist items in bugtracker
  path /{taskId}/checklist/{checklistItemId} is TaskChecklistItem {
    create() {}
    read() {}
  }

  path /{taskId}/comment/{commentId} is TaskComment {
    // create, read, write, delete rules are the same as TaskDetails
  }
}
