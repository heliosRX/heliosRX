import { _Vue as Vue } from '../install'
import GenericModel from '../classes/GenericModel'
import GenericList from '../classes/GenericList'

// -----------------------------------------------------------------------------
export function add_custom_getters( context, target, getters ) {

  if ( target.getters ) {
    console.warn(`Name conflict: property getters already exists`);
  } else {
    target.getters = {}
  }

  const computed = {}
  for ( let key in getters ) {

    let fn = getters[key]
    // computed[ key ] = () => fn( context )
    // computed[ key ] = () => fn( ...context )
    // computed[ key ] = () => fn.apply(target, Object.values(context))
    computed[ key ] = () => fn.apply(target, context) // TODO: Test if works with reactivty

    /*
    if ( Object.prototype.hasOwnProperty.call( target, key ) ) {
      let name = context.store.name;
      console.warn(`Name conflict: property "${key}" has same name as an existing class property "${key}" in ${name}`);
      continue
    }
    */

    // TODO: Assign to target.getters ?

    // Object.defineProperty( target.getters.prototype, key, {
    Object.defineProperty( target.getters, key, {
      get: () => _vm[key],
      // get: function() {Â return _vm[key].apply( target ) }, // Does not work
      // enumerable: false
      enumerable: true // schon ok
    })
  }

  const _vm = new Vue({
    computed
  })

  return _vm;
}

// -----------------------------------------------------------------------------
export function add_custom_actions( context, target, actions, reset ) {
  for ( let key in actions ) {
    let action = actions[ key ];
    if ( reset ) {
      delete target[ key ]
    }
    if ( Object.prototype.hasOwnProperty.call( target, key ) ) {
      let name = context.$store.name;
      console.warn(`Name conflict: action "${key}" has same name as another property "${key}" in ${name}`);
      continue
    }
    // Object.defineProperty( target, key, { value: () => action(context) } )
    Object.defineProperty( target, key, {
      value: (...args) => action.apply(target, [context, ...args] ),
      enumerable: true // otherwise not cloned
    })
  }
}

// -----------------------------------------------------------------------------
export function make_reactive_list( modelDefinition, dataList, context, no_reactive_getters = false ) {
  let name = context.store.name;
  let reactive_list = new GenericList( name );

  if ( dataList ) {
    for ( let id in dataList ) {
      let item = make_reactive_model( modelDefinition, dataList[ id ], context )
      item.$id = id;
      item._update_data( dataList[ id ], modelDefinition.schema.fields ) // DOPPELT?
      reactive_list._add_child( id, item );
    }
    reactive_list.$readyAll = true;
    reactive_list.$numReady = Object.keys( dataList ).length;
  }

  if ( modelDefinition.listActions ) {
    reactive_list.decorate_actions( modelDefinition.listActions, context );
  }

  if ( modelDefinition.listGetters
       && !no_reactive_getters
       && !modelDefinition.no_reactive_getters ) {
    reactive_list.decorate_getters( modelDefinition.listGetters, context.registry );
  }

  Vue.observable( reactive_list );
  return reactive_list
}

// -----------------------------------------------------------------------------
export function make_reactive_model(
  modelDefinition,
  data,
  context,
  is_dirty = false,
  no_reactive_getters = false
) {

  let name = context.store.name;
  let load_result = new GenericModel( null, null, name )
  load_result._set_generic_store( context.store );

  // console.log( "[GENS:make_reactive_model] name", name, "data", data );

  if ( modelDefinition.schema && modelDefinition.schema.fields ) {
    load_result.autogenerate_props( modelDefinition.schema.fields, data, is_dirty )
  } else {
    console.warn('Making a reactive model without schema. This means props are not autogenerated and only accessible through model.$state. Please provide a schema for ' + name + '.');
  }

  if ( data ) {
    load_result._update_data( data, modelDefinition.schema.fields )
    load_result.$ready = true;
  }

  if ( modelDefinition.modelActions ) {
    load_result.decorate_actions( modelDefinition.modelActions, context );
  }

  /* add model getters:
     - attach vm only if there are getters - otherwise there is no need
     - attach vm only if flag 'no_reactive_getters' is not set in model definition
     - attach vm only if flag 'no_reactive_getters' is not set during model instantiation
  */
  if ( modelDefinition.modelGetters
       && !no_reactive_getters
       && !modelDefinition.no_reactive_getters ) {
    load_result.decorate_getters( modelDefinition.modelGetters, context.registry );
  }

  /*
  if ( module.hot && modelDefinition.hotUpdate ) {
    // TODO: Testen
    let hotUpdateList = modelDefinition.hotUpdate();
    let filelist = []
    for ( let relative_filename in hotUpdateList ) {
      let filename = './src/models/' + name + '/' + relative_filename;
      filelist.push( filename )
    }
    console.log("[HMR] list", filelist);
    module.hot.accept([filelist], (updated_file, deps) => {
      console.log("[HMR] update model", updated_file, deps);
      // Parse "./src/api/<moduleName>.js"
      let moduleName = updated_file[0].split('/').pop();
      console.log("[HMR] update model %c<" + moduleName + ">", 'color: #42b983');
      let target = hotUpdateList[ moduleName ];
      let moduleData = require('./src/models/' + name + '/' + moduleName)
      for ( var prop in moduleData ) {
        target[ prop ] = moduleData[ prop ]
      }
      // Why not just update entire model?
    })
  }
  */

  // Vue.observable( load_result.$state ); // DOPPELT
  Vue.observable( load_result );

  // console.log( "[GENS:make_reactive_model] load_result", load_result );
  return load_result;
}
